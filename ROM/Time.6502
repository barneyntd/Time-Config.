\ System constants
OSWORDPtr	= &F0
OSWORDNum	= &EF
OSBYTEA		= &EF
OSBYTEX		= &F0
OSBYTEY		= &F1
TextPointer	= &F2
TempSpace	= &A8		\\ A8 - AF supposed to be usable for OS commands
TempSpace2	= &E4		\\ E4 - E6 general purpose
EVENTV		= &220
OSASCI		= &FFE3
OSWRCH		= &FFEE
OSNEWL		= &FFE7
GSREAD		= &FFC5
GSINIT		= &FFC2

DEBUG_CLOCK = 0			\\ change OSBYTE &A1 & &A2 to read upper page of NVRAM
SAVE_ALARMS = 0			\\ implement Ann=... to save dates & times in NVRAM
SAVE_SETTIME = 1		\\ save date & time of last set in UTC
CALIBRATION = 1			\\ implement C+-cc to adjust offset register


ORG &8000

.codeStart

\*******************************************************\
\														\
\				ROM header								\
\														\
\*******************************************************\

	EQUB 0,0,0				\\ not a language
	JMP ROM_service
	EQUB &82				\\ 6502 code, no relocation, not a language, service
	EQUB ROM_copyright - codeStart - 1
	EQUB 01					\\ version 01
	EQUS "Time", 0			\\ Title
.ROM_copyright
	EQUS "(C) 2023 Barney Hilken", 0
	EQUD 0

.ROM_service
	CMP #1
	BNE notSetup
	JSR VIA_setup			\\ Setup after reset
	LDA #1
	RTS
.notSetup
	CMP #4
	BNE notCommand
	JMP doOSCLI				\\ perform OSCLI command
.notCommand
	CMP #7
	BNE notOSBYTE
	LDA OSBYTEA				\\ Check OSBYTE number
	CMP #&A1
	BNE notOSBYTEA1
	LDX OSBYTEX
IF DEBUG_CLOCK
	SEC
ELSE
	CLC
ENDIF
	JSR FRAM_readByte		\\ perform OSBYTE &A1
	LDA #0
	RTS
.notOSBYTEA1
	CMP #&A2
	BNE notOSBYTEA2
	LDX OSBYTEX
	LDY OSBYTEY
IF DEBUG_CLOCK
	SEC
ELSE
	CLC
ENDIF
	JSR FRAM_writeByte		\\ perform OSBYTE &A2
	LDA #0
	RTS
.notOSBYTEA2
	LDA #7
	RTS
.notOSBYTE
	CMP #8
	BNE notOSWORD
	TYA
	PHA
	TXA
	PHA
	LDA OSWORDNum			\\ Check OSWORD number
	CMP #&0E
	BNE notOSWORD0E
	JSR OSWORD0E			\\ perform OSWORD &0E
	JMP done
.notOSWORD0E
	CMP #&0F
	BNE notOSWORD0F
	JSR OSWORD0F			\\ perform OSWORD &0F
	JMP done
.notOSWORD0F
	LDA #7
.done
	STA TempSpace
	PLA
	TAX
	PLA
	TAY
	LDA TempSpace
.notOSWORD
	RTS

\*******************************************************\
\														\
\				OSCLI									\
\														\
\*******************************************************\
.TIMEstring
	EQUS "TIME", &0
	
.doOSCLI
	TYA
	PHA
	TXA
	PHA
	CLC
	JSR GSINIT				\\ start parsing line
	BEQ notTime
	LDX #0					\\ index through "TIME"
.timeLoop
	JSR GSREAD				\\ next character
	BCS notTime				\\ end of word before end of "TIME"
	AND #LO(NOT(&20))		\\ capitalise
	EOR TIMEstring,X		\\ compare with "TIME"
	BNE notTime
	INX	
	LDA TIMEstring,X		\\ check for end of "TIME"
	BNE timeLoop			\\ loop to next char
	JSR GSREAD				\\ next character
	BCC notTime				\\ not end of word
	BNE setTime				\\ not end of line
.printTime
	LDY #0
	STY OSWORDPtr+1
	JSR RTC_readTimeString	\\ read current time and send to OSWRCH
	LDA #0
	JMP done
.notTime
	LDA #4
	BNE done


.setTime
	STY TempSpace			\\ save Y
	LDX #1					\\ count rest of line, except trailing spaces
.setTimeLoop
	STX TempSpace+1
.noSaveLoop
	INY
	INX
	LDA (TextPointer),Y
	CMP #&0D				\\ check for end of line
	BEQ endOfText
	CMP #' '				\\ check for whitespace
	BNE setTimeLoop
	BEQ noSaveLoop
.endOfText
	LDA TextPointer
	STA OSWORDPtr
	LDA TextPointer+1
	STA OSWORDPtr+1
	LDY TempSpace			\\ back to saved point
	LDA TempSpace+1			\\ retrieve length without trailing whitespace
	JSR doOSWORD0F
	BEQ done
	LDY #timeErrorEnd - timeError - 1
.timeErrorLoop
	LDA timeError,Y
	STA &0100,Y
	DEY
	BPL timeErrorLoop
	JMP &0100
.timeError
	BRK
	EQUS 252, "Bad time", 0
.timeErrorEnd

\*******************************************************\
\														\
\				OSWORD 14 & 15							\
\														\
\*******************************************************\

.OSWORD0E					\\ Read clock in various ways. Preserves X, Y, sets A to 0 if done or 8 if not done
	LDY #0
	LDA (OSWORDPtr),Y		\\ function determined by first byte in buffer
	BNE notReadTimeString	\\ 0: read date & time as string
	JSR RTC_readTimeString
	LDA #0
	RTS
.notReadTimeString
	CMP #1					\\ 1: read date & time as BCD
	BNE notReadTimeBCD
	JSR RTC_readTimeBCD
	LDA #0
	RTS
.notReadTimeBCD
	CMP #2					\\ 2: convert BCD date & time to string
	BNE notConvertBCDTime	
	JSR RTC_ConvertTimeString
	LDA #0
	RTS
.notConvertBCDTime
	CMP #7					\\ 7: read timezone as signed BCD
	BNE notReadTimezone	
	JSR RTC_ReadTimezoneBCD
	LDA #0
	RTS
.notReadTimezone
IF SAVE_ALARMS OR SAVE_SETTIME
	INY
	CMP #5					\\ 5: read alarm date & time as string
	BNE notReadAlarmString
	LDA (OSWORDPtr),Y		\\ alarm number determined by second byte in buffer
	JSR RTC_readAlarmString
	LDA #0
	RTS
.notReadAlarmString
	CMP #6					\\ 6: read alarm date & time as BCD
	BNE notReadAlarmBCD
	LDA (OSWORDPtr),Y		\\ alarm number determined by second byte in buffer
	JSR RTC_readAlarmBCD
	LDA #0
	RTS
.notReadAlarmBCD
ENDIF
	LDA #8
	RTS

.OSWORD0F					\\ set date, time & alarm from string. Preserves X, Y, sets A to 0 if done or 8 if not done
	LDY #0
	LDA (OSWORDPtr),Y
	BEQ OSW_unused
	INY
.doOSWORD0F
	CMP #25
	BCS OSW_unused
IF SAVE_ALARMS
	ASL A					\\ 2 - 48 even
	TAX
	LDA (OSWORDPtr),Y
	AND #LO(NOT(&20))		\\ ignore capitalisation
	CMP #'A'				\\ check for alarm
	BEQ alarmTable
	DEX
.alarmTable
	TXA						\\ 1 - 48, even = alarm
ENDIF
	ASL A
	TAX	
	JSR OSW_JMPtable
.doneOSWORD0f
	BCC OSW_unused			\\ error in time string
	LDA #0
	RTS
.OSW_unused
	LDA #8
	RTS
.OSW_JMPtable
	LDA OSWORDJMPtable-1,X	\\ address high
	PHA
	LDA OSWORDJMPtable-2,X	\\ address low
	PHA
	RTS

.OSW_oneChar
	LDA (OSWORDPtr),Y
	AND #LO(NOT(&20))		\\ ignore capitalisation
	CMP #'S'
	BNE OSW_unused
	JSR RTC_Synchronise
	JMP doneOSWORD0f

IF SAVE_ALARMS
.OSW_fifteen
	TYA
	PHA
	CLC
	ADC #6					\\ Ann=dd.
	TAY
	LDA (OSWORDPtr),Y
	CMP #'.'
	BNE notSetAlarmMonthly
	PLA
	TAY
	JSR RTC_setAlarmMonthly
	JMP doneOSWORD0f
.notSetAlarmMonthly
	PLA
	TAY
	JSR RTC_setAlarmYearlyOrdNT
	JMP doneOSWORD0f
ENDIF



INCLUDE "VIA.6502"
INCLUDE "Clock.6502"
INCLUDE "TimeStrings.6502"
IF SAVE_ALARMS OR SAVE_SETTIME
	INCLUDE "SaveTimes.6502"
ENDIF


.OSWORDJMPtable
IF CALIBRATION = 0
	RTC_tuneClock = OSW_unused
ENDIF
IF SAVE_ALARMS
	EQUW OSW_oneChar-1, OSW_unused-1, OSW_unused-1, OSW_unused-1, RTC_setBSTZone-1, OSW_unused-1, RTC_tuneClock-1, RTC_clearAlarm-1
	EQUW OSW_unused-1, OSW_unused-1, RTC_setTimeZone-1, RTC_setAlarmMonthlyNT-1, RTC_incSeconds-1, RTC_setAlarmWeeklyNT-1, RTC_setTimeOnly-1, OSW_unused-1
	EQUW OSW_unused-1, RTC_setAlarmHourly-1, OSW_unused-1, RTC_setAlarmYearlyNT-1, OSW_unused-1, RTC_setAlarmMonthlyOrdNT-1, OSW_unused-1, RTC_setAlarmDaily-1
	EQUW OSW_unused-1, OSW_unused-1, OSW_unused-1, OSW_unused-1, RTC_setDateOnly-1, OSW_fifteen-1, OSW_unused-1, RTC_setAlarmWeekly-1
	EQUW OSW_unused-1, OSW_unused-1, OSW_unused-1, OSW_unused-1, OSW_unused-1, RTC_setAlarmYearly-1, OSW_unused-1, RTC_setAlarmMonthlyOrd-1
	EQUW OSW_unused-1, OSW_unused-1, OSW_unused-1, OSW_unused-1, OSW_unused-1, OSW_unused-1, RTC_setDateTime-1, RTC_setAlarmYearlyOrd-1
ELSE
	EQUW OSW_oneChar-1, OSW_unused-1, RTC_setBSTZone-1, RTC_tuneClock-1
	EQUW OSW_unused-1, RTC_setTimeZone-1, RTC_incSeconds-1, RTC_setTimeOnly-1
	EQUW OSW_unused-1, OSW_unused-1, OSW_unused-1, OSW_unused-1
	EQUW OSW_unused-1, OSW_unused-1, RTC_setDateOnly-1, OSW_unused-1
	EQUW OSW_unused-1, OSW_unused-1,OSW_unused-1, OSW_unused-1
	EQUW OSW_unused-1, OSW_unused-1,OSW_unused-1, RTC_setDateTime-1
ENDIF



.codeEnd

PRINT "Code size ", codeEnd - codeStart, "bytes"
SAVE "TIME", codeStart, codeEnd, VIA_setup
